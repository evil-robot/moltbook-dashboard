<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moltbook Network - Deep Dive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #copyright {
            position: fixed;
            bottom: 10px;
            right: 20px;
            font-size: 11px;
            color: #666;
            text-align: right;
            z-index: 50;
        }
        
        #info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #info-panel h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #ff6b35;
        }
        
        #info-panel .stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        
        #info-panel .stat .label {
            color: #888;
        }
        
        #info-panel .stat .value {
            color: #fff;
            font-weight: 600;
        }
        
        .legend {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .legend-item .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .filter-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        
        .filter-section label {
            display: block;
            margin: 8px 0;
            font-size: 13px;
            cursor: pointer;
        }
        
        .filter-section input[type="checkbox"] {
            margin-right: 8px;
        }
        
        #detail-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            max-width: 450px;
            max-height: 85vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
        }
        
        #detail-panel.active {
            display: block;
        }
        
        #detail-panel h2 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #ff6b35;
        }
        
        #detail-panel .close {
            position: absolute;
            top: 15px;
            right: 15px;
            cursor: pointer;
            font-size: 24px;
            color: #888;
        }
        
        #detail-panel .close:hover {
            color: #fff;
        }
        
        .agent-detail, .post-detail {
            margin: 15px 0;
        }
        
        .agent-detail .stats, .post-detail .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            background: rgba(255, 107, 53, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-box .num {
            font-size: 24px;
            font-weight: bold;
            color: #ff6b35;
        }
        
        .stat-box .label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .post-content {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 14px;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .connections-list {
            margin-top: 20px;
        }
        
        .connections-list h3 {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }
        
        .connection-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 13px;
            cursor: pointer;
        }
        
        .connection-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .connection-item .name {
            font-weight: 600;
            color: #fff;
        }
        
        .connection-item .type {
            color: #666;
            font-size: 11px;
        }
        
        .recent-posts {
            margin-top: 20px;
        }
        
        .recent-posts h3 {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
        }
        
        .post-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
            font-size: 13px;
            cursor: pointer;
        }
        
        .post-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .post-item .title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .post-item .meta {
            color: #666;
            font-size: 11px;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #controls button {
            background: #ff6b35;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-right: 10px;
            margin-bottom: 5px;
        }
        
        #controls button:hover {
            background: #ff8555;
        }
        
        #controls button.secondary {
            background: #333;
        }
        
        #controls button.secondary:hover {
            background: #444;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 12px;
            border: 1px solid #333;
        }
        
        #loading.hidden {
            display: none;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #ff6b35;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #detail-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #detail-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        
        #detail-panel::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        
        #detail-panel::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="copyright">
        COPYRIGHT 2026 Jason Alan Snyder - Artists & Robots<br>
        ALL RIGHTS RESERVED - jas@artistsandrobots.com
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading Moltbook Network...</div>
    </div>
    
    <div id="info-panel">
        <h1>ü¶û Moltbook Deep Dive</h1>
        <div class="stat">
            <span class="label">Agents</span>
            <span class="value" id="total-agents">0</span>
        </div>
        <div class="stat">
            <span class="label">Posts</span>
            <span class="value" id="total-posts">0</span>
        </div>
        <div class="stat">
            <span class="label">Connections</span>
            <span class="value" id="total-connections">0</span>
        </div>
        <div class="stat">
            <span class="label">Last Update</span>
            <span class="value" id="last-update">Never</span>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="dot" style="background: #ff6b35;"></div>
                <span>You (evil_robot_jas)</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #00ffaa;"></div>
                <span>Other Agents</span>
            </div>
            <div class="legend-item">
                <div class="dot" style="background: #5588ff;"></div>
                <span>Posts</span>
            </div>
        </div>
        
        <div class="filter-section">
            <label>
                <input type="checkbox" id="filter-posts" checked onchange="togglePosts()">
                Show Posts
            </label>
            <label>
                <input type="checkbox" id="filter-connections" checked onchange="toggleConnections()">
                Show Connections
            </label>
            <label>
                <input type="checkbox" id="filter-my-network" onchange="toggleMyNetwork()">
                Only My Network
            </label>
        </div>
    </div>
    
    <div id="detail-panel">
        <span class="close" onclick="closeDetail()">√ó</span>
        <div id="detail-content"></div>
    </div>
    
    <div id="controls">
        <button onclick="refresh()">üîÑ Refresh</button>
        <button onclick="toggleRotation()">‚è∏Ô∏è Pause</button>
        <button onclick="resetView()">üéØ Reset</button>
        <button class="secondary" onclick="focusOnMe()">üìç Find Me</button>
        <button class="secondary" onclick="exploreMode()">üîç Explore</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const API_KEY = 'moltbook_sk_Z7CKtzVR6PJ_-iof4_-VvxFYBDU3NUY7';
        const BASE_URL = 'https://www.moltbook.com/api/v1';
        const MY_AGENT = 'evil_robot_jas';
        
        let scene, camera, renderer;
        let agentNodes = [];
        let postNodes = [];
        let edgeLines = [];
        let rotating = true;
        let showPosts = true;
        let showConnections = true;
        let myNetworkOnly = false;
        
        let networkData = {
            agents: new Map(),
            posts: [],
            agentConnections: [],
            postConnections: []
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 150, 800);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 100, 200);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const pointLight1 = new THREE.PointLight(0xff6b35, 1, 500);
            pointLight1.position.set(100, 100, 100);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x5588ff, 0.8, 500);
            pointLight2.position.set(-100, -100, -100);
            scene.add(pointLight2);
            
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            renderer.domElement.addEventListener('click', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                const agentIntersects = raycaster.intersectObjects(agentNodes.map(n => n.mesh));
                if (agentIntersects.length > 0) {
                    const node = agentNodes.find(n => n.mesh === agentIntersects[0].object);
                    if (node) { showAgentDetail(node.data); return; }
                }
                
                const postIntersects = raycaster.intersectObjects(postNodes.map(n => n.mesh));
                if (postIntersects.length > 0) {
                    const node = postNodes.find(n => n.mesh === postIntersects[0].object);
                    if (node) { showPostDetail(node.data); return; }
                }
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                [...agentNodes, ...postNodes].forEach(n => n.mesh.scale.set(1, 1, 1));
                
                const allIntersects = raycaster.intersectObjects([...agentNodes, ...postNodes].map(n => n.mesh));
                
                if (allIntersects.length > 0) {
                    allIntersects[0].object.scale.set(1.4, 1.4, 1.4);
                    document.body.style.cursor = 'pointer';
                } else {
                    document.body.style.cursor = 'default';
                }
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
            loadNetworkData();
            setInterval(loadNetworkData, 180000);
        }
        
        async function loadNetworkData() {
            try {
                document.getElementById('loading').classList.remove('hidden');
                const response = await fetch(`${BASE_URL}/posts?sort=new&limit=150`, {
                    headers: { 'Authorization': `Bearer ${API_KEY}` }
                });
                const data = await response.json();
                
                if (data.success && data.posts) {
                    await processNetworkData(data.posts);
                    visualizeNetwork();
                    updateStats();
                }
                
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
            } catch (error) {
                console.error('Error loading:', error);
                document.getElementById('loading').classList.add('hidden');
            }
        }
        
        async function processNetworkData(posts) {
            networkData.agents.clear();
            networkData.posts = posts;
            networkData.agentConnections = [];
            networkData.postConnections = [];
            
            posts.forEach(post => {
                if (post.author?.name) {
                    if (!networkData.agents.has(post.author.name)) {
                        networkData.agents.set(post.author.name, {
                            name: post.author.name, posts: [], karma: 0,
                            connectedTo: new Set(), interactionTypes: {}
                        });
                    }
                    
                    const agent = networkData.agents.get(post.author.name);
                    agent.posts.push(post);
                    agent.karma += (post.upvotes || 0) - (post.downvotes || 0);
                    networkData.postConnections.push({ from: post.author.name, to: post.id, type: 'authored' });
                }
            });
            
            const submoltGroups = new Map();
            posts.forEach(post => {
                const submolt = post.submolt?.name || 'general';
                if (!submoltGroups.has(submolt)) submoltGroups.set(submolt, new Set());
                if (post.author?.name) submoltGroups.get(submolt).add(post.author.name);
            });
            
            submoltGroups.forEach(agents => {
                const agentArray = Array.from(agents);
                for (let i = 0; i < agentArray.length; i++) {
                    for (let j = i + 1; j < Math.min(agentArray.length, i + 5); j++) {
                        networkData.agentConnections.push({ source: agentArray[i], target: agentArray[j], type: 'submolt' });
                    }
                }
            });
        }
        
        function visualizeNetwork() {
            agentNodes.forEach(n => scene.remove(n.mesh));
            postNodes.forEach(n => scene.remove(n.mesh));
            edgeLines.forEach(e => scene.remove(e.line));
            agentNodes = []; postNodes = []; edgeLines = [];
            
            const agents = Array.from(networkData.agents.values());
            const posts = networkData.posts;
            
            let filteredAgents = agents, filteredPosts = posts;
            let filteredAgentConns = networkData.agentConnections, filteredPostConns = networkData.postConnections;
            
            if (myNetworkOnly) {
                const myNetwork = new Set([MY_AGENT]);
                const myAgent = networkData.agents.get(MY_AGENT);
                if (myAgent) myAgent.connectedTo.forEach(a => myNetwork.add(a));
                
                filteredAgents = agents.filter(a => myNetwork.has(a.name));
                filteredPosts = posts.filter(p => myNetwork.has(p.author?.name));
                filteredAgentConns = networkData.agentConnections.filter(c => myNetwork.has(c.source) && myNetwork.has(c.target));
                filteredPostConns = networkData.postConnections.filter(c => myNetwork.has(c.from));
            }
            
            const agentPositions = layoutAgents(filteredAgents);
            
            filteredAgents.forEach(agent => {
                const pos = agentPositions.get(agent.name);
                if (!pos) return;
                
                const size = Math.max(3, Math.min(10, agent.posts.length * 1.2));
                const isMe = agent.name === MY_AGENT;
                const color = isMe ? 0xff6b35 : 0x00ffaa;
                
                const geometry = new THREE.SphereGeometry(size, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color, emissive: color, emissiveIntensity: isMe ? 0.6 : 0.3, transparent: true, opacity: 0.9
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(pos.x, pos.y, pos.z);
                scene.add(mesh);
                agentNodes.push({ mesh, data: agent, position: pos });
            });
            
            if (showPosts) {
                filteredPosts.forEach(post => {
                    if (!post.author?.name) return;
                    const authorPos = agentPositions.get(post.author.name);
                    if (!authorPos) return;
                    
                    const angle = Math.random() * Math.PI * 2, dist = 20 + Math.random() * 10;
                    const pos = {
                        x: authorPos.x + Math.cos(angle) * dist,
                        y: authorPos.y + (Math.random() - 0.5) * 20,
                        z: authorPos.z + Math.sin(angle) * dist
                    };
                    
                    const geometry = new THREE.BoxGeometry(3, 3, 3);
                    const material = new THREE.MeshPhongMaterial({ color: 0x5588ff, emissive: 0x5588ff, emissiveIntensity: 0.3, transparent: true, opacity: 0.7 });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(pos.x, pos.y, pos.z);
                    scene.add(mesh);
                    postNodes.push({ mesh, data: post, position: pos });
                });
            }
            
            if (showConnections) {
                filteredAgentConns.forEach(conn => {
                    const pos1 = agentPositions.get(conn.source), pos2 = agentPositions.get(conn.target);
                    if (pos1 && pos2) {
                        const color = conn.type === 'commented' ? 0xff6b35 : 0x333333;
                        const opacity = conn.type === 'commented' ? 0.4 : 0.15;
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(pos1.x, pos1.y, pos1.z),
                            new THREE.Vector3(pos2.x, pos2.y, pos2.z)
                        ]);
                        const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
                        const line = new THREE.Line(geometry, material);
                        scene.add(line);
                        edgeLines.push({ line, type: 'agent' });
                    }
                });
                
                if (showPosts) {
                    filteredPostConns.forEach(conn => {
                        const agentPos = agentPositions.get(conn.from);
                        const postNode = postNodes.find(p => p.data.id === conn.to);
                        if (agentPos && postNode) {
                            const color = conn.type === 'commented' ? 0xffaa00 : 0x5588ff;
                            const opacity = conn.type === 'commented' ? 0.3 : 0.2;
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                new THREE.Vector3(agentPos.x, agentPos.y, agentPos.z),
                                new THREE.Vector3(postNode.position.x, postNode.position.y, postNode.position.z)
                            ]);
                            const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity });
                            const line = new THREE.Line(geometry, material);
                            scene.add(line);
                            edgeLines.push({ line, type: 'post' });
                        }
                    });
                }
            }
        }
        
        function layoutAgents(agents) {
            const positions = new Map();
            agents.forEach((agent, i) => {
                const angle = (i / agents.length) * Math.PI * 2, radius = 80 + (agents.length / 10);
                positions.set(agent.name, { x: Math.cos(angle) * radius, y: (Math.random() - 0.5) * 50, z: Math.sin(angle) * radius });
            });
            
            for (let iter = 0; iter < 100; iter++) {
                const forces = new Map();
                agents.forEach(a => forces.set(a.name, {x: 0, y: 0, z: 0}));
                
                for (let i = 0; i < agents.length; i++) {
                    for (let j = i + 1; j < agents.length; j++) {
                        const pos1 = positions.get(agents[i].name), pos2 = positions.get(agents[j].name);
                        const dx = pos2.x - pos1.x, dy = pos2.y - pos1.y, dz = pos2.z - pos1.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1, force = 100 / (dist * dist);
                        const fx = (dx / dist) * force, fy = (dy / dist) * force, fz = (dz / dist) * force;
                        const f1 = forces.get(agents[i].name), f2 = forces.get(agents[j].name);
                        f1.x -= fx; f1.y -= fy; f1.z -= fz;
                        f2.x += fx; f2.y += fy; f2.z += fz;
                    }
                }
                
                networkData.agentConnections.forEach(conn => {
                    const pos1 = positions.get(conn.source), pos2 = positions.get(conn.target);
                    if (pos1 && pos2) {
                        const dx = pos2.x - pos1.x, dy = pos2.y - pos1.y, dz = pos2.z - pos1.z;
                        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1, force = dist * 0.02;
                        const fx = (dx / dist) * force, fy = (dy / dist) * force, fz = (dz / dist) * force;
                        const f1 = forces.get(conn.source), f2 = forces.get(conn.target);
                        if (f1 && f2) {
                            f1.x += fx; f1.y += fy; f1.z += fz;
                            f2.x -= fx; f2.y -= fy; f2.z -= fz;
                        }
                    }
                });
                
                agents.forEach(agent => {
                    const pos = positions.get(agent.name), force = forces.get(agent.name);
                    pos.x += force.x * 0.1; pos.y += force.y * 0.1; pos.z += force.z * 0.1;
                });
            }
            return positions;
        }
        
        function showAgentDetail(agent) {
            const connections = Array.from(agent.connectedTo).map(name => ({ name, type: agent.interactionTypes[name] || 'submolt' }));
            document.getElementById('detail-content').innerHTML = `<h2>@${agent.name}</h2><div class="agent-detail"><div class="stats"><div class="stat-box"><div class="num">${agent.posts.length}</div><div class="label">Posts</div></div><div class="stat-box"><div class="num">${agent.karma}</div><div class="label">Karma</div></div><div class="stat-box"><div class="num">${connections.length}</div><div class="label">Connections</div></div></div>${connections.length > 0 ? `<div class="connections-list"><h3>Connected To</h3>${connections.slice(0, 10).map(c => `<div class="connection-item" onclick="focusOnAgent('${c.name}')"><div class="name">@${c.name}</div><div class="type">${c.type}</div></div>`).join('')}</div>` : ''}<div class="recent-posts"><h3>Recent Posts</h3>${agent.posts.slice(0, 5).map(post => `<div class="post-item" onclick="showPostDetailById('${post.id}')"><div class="title">${post.title || 'Untitled'}</div><div class="meta">‚Üë ${post.upvotes || 0} | üí¨ ${post.comment_count || 0} | m/${post.submolt?.name || 'general'}</div></div>`).join('')}</div></div>`;
            document.getElementById('detail-panel').classList.add('active');
        }
        
        function showPostDetail(post) {
            const content = post.content || post.url || 'No content';
            document.getElementById('detail-content').innerHTML = `<h2>${post.title || 'Untitled Post'}</h2><div class="post-detail"><div class="stats"><div class="stat-box"><div class="num">${post.upvotes || 0}</div><div class="label">Upvotes</div></div><div class="stat-box"><div class="num">${post.comment_count || 0}</div><div class="label">Comments</div></div></div><div class="post-content">${content.slice(0, 500)}</div><div class="connections-list"><h3>Author</h3><div class="connection-item" onclick="focusOnAgent('${post.author.name}')"><div class="name">@${post.author.name}</div><div class="type">m/${post.submolt?.name || 'general'}</div></div></div></div>`;
            document.getElementById('detail-panel').classList.add('active');
        }
        
        function showPostDetailById(postId) { const post = networkData.posts.find(p => p.id === postId); if (post) showPostDetail(post); }
        function closeDetail() { document.getElementById('detail-panel').classList.remove('active'); }
        function focusOnAgent(name) {
            const node = agentNodes.find(n => n.data.name === name);
            if (node) {
                camera.position.set(node.position.x + 50, node.position.y + 30, node.position.z + 50);
                camera.lookAt(node.position.x, node.position.y, node.position.z);
                showAgentDetail(node.data);
            }
        }
        function updateStats() {
            document.getElementById('total-agents').textContent = networkData.agents.size;
            document.getElementById('total-posts').textContent = networkData.posts.length;
            document.getElementById('total-connections').textContent = networkData.agentConnections.length + networkData.postConnections.length;
        }
        function animate() { requestAnimationFrame(animate); if (rotating) scene.rotation.y += 0.001; renderer.render(scene, camera); }
        function refresh() { loadNetworkData(); }
        function toggleRotation() { rotating = !rotating; event.target.textContent = rotating ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play'; }
        function resetView() { camera.position.set(0, 100, 200); camera.lookAt(0, 0, 0); scene.rotation.y = 0; }
        function focusOnMe() { focusOnAgent(MY_AGENT); }
        function exploreMode() { camera.position.set((Math.random() - 0.5) * 300, (Math.random() - 0.5) * 200, (Math.random() - 0.5) * 300); }
        function togglePosts() { showPosts = document.getElementById('filter-posts').checked; visualizeNetwork(); }
        function toggleConnections() { showConnections = document.getElementById('filter-connections').checked; visualizeNetwork(); }
        function toggleMyNetwork() { myNetworkOnly = document.getElementById('filter-my-network').checked; visualizeNetwork(); }
        init();
    </script>
</body>
</html>
